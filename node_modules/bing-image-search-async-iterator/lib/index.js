"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = search;

var _crossFetch = _interopRequireDefault(require("cross-fetch"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume("next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

if (typeof Symbol === "function" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

const apiEndPoint = 'https://api.cognitive.microsoft.com/bing/v7.0/images/search';
const HEADERS = {
  API_KEY: 'Ocp-Apim-Subscription-Key',
  CLIENT_ID: 'X-MSEdge-ClientID',
  CLIENT_IP: 'X-MSEdge-ClientIP',
  LOCATION: 'X-Search-Location',
  ACCEPT: 'Accept'
};
const acceptHeaderValue = 'application/json';

function filterNulls(obj) {
  return Object.keys(obj).filter(key => obj[key] != null).reduce((acc, key) => {
    acc[key] = obj[key];
    return acc;
  }, {});
}

function stringify(obj) {
  return Object.keys(obj).map(k => `${encodeURIComponent(k)}=${encodeURIComponent(obj[k])}`).join('&');
}

function search() {
  return _search.apply(this, arguments);
}

function _search() {
  _search = _wrapAsyncGenerator(function* ({
    key,
    query,
    market,
    safeSearch,
    aspect,
    color,
    imageContent,
    imageType,
    license,
    freshness,
    size,
    width,
    height,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    minFileSize,
    maxFileSize,
    offset = 0,
    count = 150,
    amount = 2000,
    clientID,
    clientIP,
    location,
    queryParams,
    headerParams,
    fetchCb = _crossFetch.default
  } = {}) {
    let currOffset = offset;
    let currAmount = amount;
    let available = currOffset + currAmount;
    let responseClientID;

    while (currOffset < Math.min(currOffset + currAmount, available)) {
      const requestParams = filterNulls(_objectSpread({
        q: query,
        mkt: market,
        safeSearch,
        aspect,
        color,
        imageContent,
        imageType,
        license,
        freshness,
        size,
        width,
        height,
        minWidth,
        minHeight,
        maxWidth,
        maxHeight,
        minFileSize,
        maxFileSize,
        offset: currOffset,
        count: Math.min(count, Math.min(currOffset + currAmount, available) - currOffset)
      }, queryParams));
      const requestHeaders = filterNulls(_objectSpread({
        [HEADERS.API_KEY]: key,
        [HEADERS.CLIENT_ID]: clientID === undefined ? responseClientID : clientID,
        [HEADERS.CLIENT_IP]: clientIP,
        [HEADERS.LOCATION]: location,
        [HEADERS.ACCEPT]: acceptHeaderValue
      }, headerParams));
      const requestOptions = {
        method: 'GET',
        headers: requestHeaders
      };
      const requestUrl = `${apiEndPoint}?${stringify(requestParams)}`;
      const response = yield _awaitAsyncGenerator(fetchCb(requestUrl, requestOptions));
      const ok = response.ok,
            status = response.status,
            statusText = response.statusText;

      if (!ok) {
        throw new Error(`HTTP error ${status}: "${statusText}"`);
      }

      const body = yield _awaitAsyncGenerator(response.json());
      currOffset = body.nextOffset;
      currAmount -= body.value.length;
      available = body.totalEstimatedMatches;
      responseClientID = response.headers.get(HEADERS.CLIENT_ID);
      yield body;
    }
  });
  return _search.apply(this, arguments);
}

module.exports = exports["default"];